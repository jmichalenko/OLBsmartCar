{"entries":[{"timestamp":1764807032239,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":7041,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":1,"length1":5226,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":121,"length1":83,"diffs":[[1,"        \"microphone\": \"*\"\n"]]},{"start1":238,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1764807600278,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":1671,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"typescript_statement\" disabled-reasons=\"pxt_automatic_disabled\" x=\"9\" y=\"24\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"namespace smartCar {\" line1=\"\" line2=\"    // --- INTERNAL VARIABLES ---\" line3=\"    let gyro_offset = 0\" line4=\"    let last_time = 0\" line5=\"    let current_angle = 0\" line6=\"\" line7=\"    // Safety Correction Speed (Always keep this low!)\" line8=\"    const CORRECTION_SPEED = 25\" line9=\"    const BRAKE_DURATION = 100\" line10=\"\" line11=\"    // MPU6050 I2C Constants\" line12=\"    const MPU_ADDR = 0x68\" line13=\"    const PWR_MGMT_1 = 0x6B\" line14=\"    const GYRO_Z_H = 0x47\" line15=\"\" line16=\"    let is_initialized = false\" line17=\"\" line18=\"    /**\" line19=\"     * Wakes up the MPU6050 and calibrates it.\" line20=\"     * MUST be called at 'On Start' while car is still!\" line21=\"     */\" line22=\"    //% block=&quot;setup and calibrate gyro&quot;\" line23=\"    //% weight=100\" line24=\"    export function setupAndCalibrate() {\" line25=\"        basic.showIcon(IconNames.No) // &quot;Don't Move!&quot;\" line26=\"\" line27=\"        // 1. WAKE UP SENSOR \" line28=\"        pins.i2cWriteNumber(MPU_ADDR, PWR_MGMT_1, NumberFormat.UInt8BE)\" line29=\"        pins.i2cWriteNumber(MPU_ADDR, 0x00, NumberFormat.UInt8BE)\" line30=\"        is_initialized = true\" line31=\"        basic.pause(100)\" line32=\"\" line33=\"        // 2. CALIBRATE \" line34=\"        let sum = 0\" line35=\"        for (let i = 0; i &lt; 20; i++) {\" line36=\"            sum += readRawGyroZ()\" line37=\"            basic.pause(50)\" line38=\"        }\" line39=\"        gyro_offset = sum / 20\" line40=\"\" line41=\"        basic.showIcon(IconNames.Yes) // Ready\" line42=\"        basic.pause(500)\" line43=\"    }\" line44=\"\" line45=\"    /**\" line46=\"     * Turns the robot to a specific angle.\" line47=\"     * @param direction Left or Right\" line48=\"     * @param target_angle Angle in degrees (e.g. 90)\" line49=\"     * @param speed Motor speed (20-100)\" line50=\"     */\" line51=\"    //% block=&quot;turn %direction by %target_angle degrees at speed %speed&quot;\" line52=\"    //% target_angle.defl=90\" line53=\"    //% speed.min=20 speed.max=100 speed.defl=50\" line54=\"    //% weight=90\" line55=\"    export function turn(direction: TurnDirection, target_angle: number, speed: number) {\" line56=\"        if (!is_initialized) return;\" line57=\"\" line58=\"        current_angle = 0\" line59=\"        last_time = control.millis()\" line60=\"\" line61=\"        // Ensure speed is positive and within safety limits\" line62=\"        speed = Math.abs(speed)\" line63=\"        if (speed &lt; 20) speed = 20\" line64=\"        if (speed &gt; 100) speed = 100\" line65=\"\" line66=\"        // Determine Motor Directions\" line67=\"        // Left Turn: Left Motor Reverse (-), Right Motor Forward (+)\" line68=\"        // Right Turn: Left Motor Forward (+), Right Motor Reverse (-)\" line69=\"\" line70=\"        let left_motor_val = 0\" line71=\"        let right_motor_val = 0\" line72=\"\" line73=\"        if (direction == TurnDirection.Left) {\" line74=\"            left_motor_val = -speed\" line75=\"            right_motor_val = speed\" line76=\"        } else {\" line77=\"            left_motor_val = speed\" line78=\"            right_motor_val = -speed\" line79=\"        }\" line80=\"\" line81=\"        // --- PHASE 1: ROUGH TURN (User Speed) ---\" line82=\"        // Stop a bit early (approx 15 degrees early) to account for momentum\" line83=\"        // If speed is very low, we don't need to stop as early\" line84=\"        let stop_early_buffer = 15\" line85=\"        if (speed &lt; 40) stop_early_buffer = 8\" line86=\"\" line87=\"        let rough_target = target_angle - stop_early_buffer\" line88=\"\" line89=\"        wuKong.setAllMotor(left_motor_val, right_motor_val)\" line90=\"\" line91=\"        while (Math.abs(current_angle) &lt; rough_target) {\" line92=\"            updateAngle()\" line93=\"            basic.pause(10)\" line94=\"        }\" line95=\"\" line96=\"        // Active Brake (Reverse motors briefly)\" line97=\"        wuKong.setAllMotor(-left_motor_val, -right_motor_val)\" line98=\"        basic.pause(BRAKE_DURATION)\" line99=\"        wuKong.stopAllMotor()\" line100=\"        basic.pause(200)\" line101=\"\" line102=\"        // --- PHASE 2: PRECISE CORRECTION (Fixed Slow Speed) ---\" line103=\"        let start_fix = control.millis()\" line104=\"\" line105=\"        // Loop until error is less than 1 degree OR 3 seconds have passed\" line106=\"        while (Math.abs(Math.abs(current_angle) - target_angle) &gt; 1 &amp;&amp; (control.millis() - start_fix &lt; 3000)) {\" line107=\"            updateAngle()\" line108=\"\" line109=\"            let current_abs = Math.abs(current_angle)\" line110=\"\" line111=\"            // Logic: Do we need to turn MORE or LESS?\" line112=\"            if (current_abs &lt; target_angle) {\" line113=\"                // Undershot -&gt; Continue in same direction at slow speed\" line114=\"                if (direction == TurnDirection.Left) {\" line115=\"                    wuKong.setAllMotor(-CORRECTION_SPEED, CORRECTION_SPEED)\" line116=\"                } else {\" line117=\"                    wuKong.setAllMotor(CORRECTION_SPEED, -CORRECTION_SPEED)\" line118=\"                }\" line119=\"            } else {\" line120=\"                // Overshot -&gt; Reverse direction at slow speed\" line121=\"                if (direction == TurnDirection.Left) {\" line122=\"                    wuKong.setAllMotor(CORRECTION_SPEED, -CORRECTION_SPEED)\" line123=\"                } else {\" line124=\"                    wuKong.setAllMotor(-CORRECTION_SPEED, CORRECTION_SPEED)\" line125=\"                }\" line126=\"            }\" line127=\"            basic.pause(20)\" line128=\"        }\" line129=\"        wuKong.stopAllMotor()\" line130=\"        basic.clearScreen()\" line131=\"    }\" line132=\"\" line133=\"    // --- INTERNAL HELPERS ---\" line134=\"\" line135=\"    function updateAngle() {\" line136=\"        let now = control.millis()\" line137=\"        let dt = (now - last_time) / 1000\" line138=\"        last_time = now\" line139=\"\" line140=\"        let gyro_reading = readRawGyroZ() - gyro_offset\" line141=\"        current_angle += gyro_reading * dt\" line142=\"    }\" line143=\"\" line144=\"    function readRawGyroZ(): number {\" line145=\"        pins.i2cWriteNumber(MPU_ADDR, GYRO_Z_H, NumberFormat.UInt8BE);\" line146=\"        let raw_data = pins.i2cReadBuffer(MPU_ADDR, 2);\" line147=\"        let h = raw_data[0]\" line148=\"        let l = raw_data[1]\" line149=\"        let value = (h &lt;&lt; 8) | l\" line150=\"\" line151=\"        if (value &gt;= 0x8000) {\" line152=\"            value = value - 0x10000\" line153=\"        }\" line154=\"        // Scale 250dps range to degrees\" line155=\"        return value / 131.0\" line156=\"    }\" line157=\"}\" numlines=\"158\"></mutation><next><block type=\"typescript_statement\" disabled-reasons=\"pxt_automatic_disabled\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" line0=\"enum TurnDirection {\" line1=\"    Left,\" line2=\"    Right\" line3=\"}\" numlines=\"4\"></mutation></block></next></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":173,"diffs":[[1,"\n/**\n * COMPLETE SMART CAR PACKAGE\n * Includes: MPU6050 Driver + Smart Turning + Speed Control\n */\n\n//% color=\"#E63022\" weight=100 icon=\"\\uf1b9\" block=\"Smart Car\"\nnamespace smartCar {\n\n    // --- INTERNAL VARIABLES ---\n    let gyro_offset = 0\n    let last_time = 0\n    let current_angle = 0\n\n    // Safety Correction Speed (Always keep this low!)\n    const CORRECTION_SPEED = 25\n    const BRAKE_DURATION = 100\n\n    // MPU6050 I2C Constants\n    const MPU_ADDR = 0x68\n    const PWR_MGMT_1 = 0x6B\n    const GYRO_Z_H = 0x47\n\n    let is_initialized = false\n\n    /**\n     * Wakes up the MPU6050 and calibrates it.\n     * MUST be called at 'On Start' while car is still!\n     */\n    //% block=\"setup and calibrate gyro\"\n    //% weight=100\n    export function setupAndCalibrate() {\n        basic.showIcon(IconNames.No) // \"Don't Move!\"\n\n        // 1. WAKE UP SENSOR \n        pins.i2cWriteNumber(MPU_ADDR, PWR_MGMT_1, NumberFormat.UInt8BE)\n        pins.i2cWriteNumber(MPU_ADDR, 0x00, NumberFormat.UInt8BE)\n        is_initialized = true\n        basic.pause(100)\n\n        // 2. CALIBRATE \n        let sum = 0\n        for (let i = 0; i < 20; i++) {\n            sum += readRawGyroZ()\n            basic.pause(50)\n        }\n        gyro_offset = sum / 20\n\n        basic.showIcon(IconNames.Yes) // Ready\n        basic.pause(500)\n    }\n\n    /**\n     * Turns the robot to a specific angle.\n     * @param direction Left or Right\n     * @param target_angle Angle in degrees (e.g. 90)\n     * @param speed Motor speed (20-100)\n     */\n    //% block=\"turn %direction by %target_angle degrees at speed %speed\"\n    //% target_angle.defl=90\n    //% speed.min=20 speed.max=100 speed.defl=50\n    //% weight=90\n    export function turn(direction: TurnDirection, target_angle: number, speed: number) {\n        if (!is_initialized) return;\n\n        current_angle = 0\n        last_time = control.millis()\n\n        // Ensure speed is positive and within safety limits\n        speed = Math.abs(speed)\n        if (speed < 20) speed = 20\n        if (speed > 100) speed = 100\n\n        // Determine Motor Directions\n        // Left Turn: Left Motor Reverse (-), Right Motor Forward (+)\n        // Right Turn: Left Motor Forward (+), Right Motor Reverse (-)\n\n        let left_motor_val = 0\n        let right_motor_val = 0\n\n        if (direction == TurnDirection.Left) {\n            left_motor_val = -speed\n            right_motor_val = speed\n        } else {\n            left_motor_val = speed\n            right_motor_val = -speed\n        }\n\n        // --- PHASE 1: ROUGH TURN (User Speed) ---\n        // Stop a bit early (approx 15 degrees early) to account for momentum\n        // If speed is very low, we don't need to stop as early\n        let stop_early_buffer = 15\n        if (speed < 40) stop_early_buffer = 8\n\n        let rough_target = target_angle - stop_early_buffer\n\n        wuKong.setAllMotor(left_motor_val, right_motor_val)\n\n        while (Math.abs(current_angle) < rough_target) {\n            updateAngle()\n            basic.pause(10)\n        }\n\n        // Active Brake (Reverse motors briefly)\n        wuKong.setAllMotor(-left_motor_val, -right_motor_val)\n        basic.pause(BRAKE_DURATION)\n        wuKong.stopAllMotor()\n        basic.pause(200)\n\n        // --- PHASE 2: PRECISE CORRECTION (Fixed Slow Speed) ---\n        let start_fix = control.millis()\n\n        // Loop until error is less than 1 degree OR 3 seconds have passed\n        while (Math.abs(Math.abs(current_angle) - target_angle) > 1 && (control.millis() - start_fix < 3000)) {\n            updateAngle()\n\n            let current_abs = Math.abs(current_angle)\n\n            // Logic: Do we need to turn MORE or LESS?\n            if (current_abs < target_angle) {\n                // Undershot -> Continue in same direction at slow speed\n                if (direction == TurnDirection.Left) {\n                    wuKong.setAllMotor(-CORRECTION_SPEED, CORRECTION_SPEED)\n                } else {\n                    wuKong.setAllMotor(CORRECTION_SPEED, -CORRECTION_SPEED)\n                }\n            } else {\n                // Overshot -> Reverse direction at slow speed\n                if (direction == TurnDirection.Left) {\n                    wuKong.setAllMotor(CORRECTION_SPEED, -CORRECTION_SPEED)\n                } else {\n                    wuKong.setAllMotor(-CORRECTION_SPEED, CORRECTION_SPEED)\n                }\n            }\n            basic.pause(20)\n        }\n        wuKong.stopAllMotor()\n        basic.clearScreen()\n    }\n\n    // --- INTERNAL HELPERS ---\n\n    function updateAngle() {\n        let now = control.millis()\n        let dt = (now - last_time) / 1000\n        last_time = now\n\n        let gyro_reading = readRawGyroZ() - gyro_offset\n        current_angle += gyro_reading * dt\n    }\n\n    function readRawGyroZ(): number {\n        pins.i2cWriteNumber(MPU_ADDR, GYRO_Z_H, NumberFormat.UInt8BE);\n        let raw_data = pins.i2cReadBuffer(MPU_ADDR, 2);\n        let h = raw_data[0]\n        let l = raw_data[1]\n        let value = (h << 8) | l\n\n        if (value >= 0x8000) {\n            value = value - 0x10000\n        }\n        // Scale 250dps range to degrees\n        return value / 131.0\n    }\n"]]},{"start1":5158,"length1":43,"diffs":[[1,"\n// Enum for dropdown menu\nenum TurnDirection {\n    Left,\n    Right\n}"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":268,"length1":41,"diffs":[[1,"        \"README.md\"\n"]]},{"start1":295,"length1":35,"diffs":[[1,"    \"preferredEditor\": \"tsprj\"\n"]]}]},{"type":"added","filename":"custom.ts","value":"/**\r\n * COMPLETE SMART CAR PACKAGE\r\n * Includes: MPU6050 Driver + Smart Turning + Speed Control\r\n */\r\n\r\n//% color=\"#E63022\" weight=100 icon=\"\\uf1b9\" block=\"Smart Car\"\r\nnamespace smartCar {\r\n\r\n    // --- INTERNAL VARIABLES ---\r\n    let gyro_offset = 0\r\n    let last_time = 0\r\n    let current_angle = 0\r\n\r\n    // Safety Correction Speed (Always keep this low!)\r\n    const CORRECTION_SPEED = 25\r\n    const BRAKE_DURATION = 100\r\n\r\n    // MPU6050 I2C Constants\r\n    const MPU_ADDR = 0x68\r\n    const PWR_MGMT_1 = 0x6B\r\n    const GYRO_Z_H = 0x47\r\n\r\n    let is_initialized = false\r\n\r\n    /**\r\n     * Wakes up the MPU6050 and calibrates it.\r\n     * MUST be called at 'On Start' while car is still!\r\n     */\r\n    //% block=\"setup and calibrate gyro\"\r\n    //% weight=100\r\n    export function setupAndCalibrate() {\r\n        basic.showIcon(IconNames.No) // \"Don't Move!\"\r\n\r\n        // 1. WAKE UP SENSOR \r\n        pins.i2cWriteNumber(MPU_ADDR, PWR_MGMT_1, NumberFormat.UInt8BE)\r\n        pins.i2cWriteNumber(MPU_ADDR, 0x00, NumberFormat.UInt8BE)\r\n        is_initialized = true\r\n        basic.pause(100)\r\n\r\n        // 2. CALIBRATE \r\n        let sum = 0\r\n        for (let i = 0; i < 20; i++) {\r\n            sum += readRawGyroZ()\r\n            basic.pause(50)\r\n        }\r\n        gyro_offset = sum / 20\r\n\r\n        basic.showIcon(IconNames.Yes) // Ready\r\n        basic.pause(500)\r\n    }\r\n\r\n    /**\r\n     * Turns the robot to a specific angle.\r\n     * @param direction Left or Right\r\n     * @param target_angle Angle in degrees (e.g. 90)\r\n     * @param speed Motor speed (20-100)\r\n     */\r\n    //% block=\"turn %direction by %target_angle degrees at speed %speed\"\r\n    //% target_angle.defl=90\r\n    //% speed.min=20 speed.max=100 speed.defl=50\r\n    //% weight=90\r\n    export function turn(direction: TurnDirection, target_angle: number, speed: number) {\r\n        if (!is_initialized) return;\r\n\r\n        current_angle = 0\r\n        last_time = control.millis()\r\n\r\n        // Ensure speed is positive and within safety limits\r\n        speed = Math.abs(speed)\r\n        if (speed < 20) speed = 20\r\n        if (speed > 100) speed = 100\r\n\r\n        // Determine Motor Directions\r\n        // Left Turn: Left Motor Reverse (-), Right Motor Forward (+)\r\n        // Right Turn: Left Motor Forward (+), Right Motor Reverse (-)\r\n\r\n        let left_motor_val = 0\r\n        let right_motor_val = 0\r\n\r\n        if (direction == TurnDirection.Left) {\r\n            left_motor_val = -speed\r\n            right_motor_val = speed\r\n        } else {\r\n            left_motor_val = speed\r\n            right_motor_val = -speed\r\n        }\r\n\r\n        // --- PHASE 1: ROUGH TURN (User Speed) ---\r\n        // Stop a bit early (approx 15 degrees early) to account for momentum\r\n        // If speed is very low, we don't need to stop as early\r\n        let stop_early_buffer = 15\r\n        if (speed < 40) stop_early_buffer = 8\r\n\r\n        let rough_target = target_angle - stop_early_buffer\r\n\r\n        wuKong.setAllMotor(left_motor_val, right_motor_val)\r\n\r\n        while (Math.abs(current_angle) < rough_target) {\r\n            updateAngle()\r\n            basic.pause(10)\r\n        }\r\n\r\n        // Active Brake (Reverse motors briefly)\r\n        wuKong.setAllMotor(-left_motor_val, -right_motor_val)\r\n        basic.pause(BRAKE_DURATION)\r\n        wuKong.stopAllMotor()\r\n        basic.pause(200)\r\n\r\n        // --- PHASE 2: PRECISE CORRECTION (Fixed Slow Speed) ---\r\n        let start_fix = control.millis()\r\n\r\n        // Loop until error is less than 1 degree OR 3 seconds have passed\r\n        while (Math.abs(Math.abs(current_angle) - target_angle) > 1 && (control.millis() - start_fix < 3000)) {\r\n            updateAngle()\r\n\r\n            let current_abs = Math.abs(current_angle)\r\n\r\n            // Logic: Do we need to turn MORE or LESS?\r\n            if (current_abs < target_angle) {\r\n                // Undershot -> Continue in same direction at slow speed\r\n                if (direction == TurnDirection.Left) {\r\n                    wuKong.setAllMotor(-CORRECTION_SPEED, CORRECTION_SPEED)\r\n                } else {\r\n                    wuKong.setAllMotor(CORRECTION_SPEED, -CORRECTION_SPEED)\r\n                }\r\n            } else {\r\n                // Overshot -> Reverse direction at slow speed\r\n                if (direction == TurnDirection.Left) {\r\n                    wuKong.setAllMotor(CORRECTION_SPEED, -CORRECTION_SPEED)\r\n                } else {\r\n                    wuKong.setAllMotor(-CORRECTION_SPEED, CORRECTION_SPEED)\r\n                }\r\n            }\r\n            basic.pause(20)\r\n        }\r\n        wuKong.stopAllMotor()\r\n        basic.clearScreen()\r\n    }\r\n\r\n    // --- INTERNAL HELPERS ---\r\n\r\n    function updateAngle() {\r\n        let now = control.millis()\r\n        let dt = (now - last_time) / 1000\r\n        last_time = now\r\n\r\n        let gyro_reading = readRawGyroZ() - gyro_offset\r\n        current_angle += gyro_reading * dt\r\n    }\r\n\r\n    function readRawGyroZ(): number {\r\n        pins.i2cWriteNumber(MPU_ADDR, GYRO_Z_H, NumberFormat.UInt8BE);\r\n        let raw_data = pins.i2cReadBuffer(MPU_ADDR, 2);\r\n        let h = raw_data[0]\r\n        let l = raw_data[1]\r\n        let value = (h << 8) | l\r\n\r\n        if (value >= 0x8000) {\r\n            value = value - 0x10000\r\n        }\r\n        // Scale 250dps range to degrees\r\n        return value / 131.0\r\n    }\r\n}\r\n\r\n// Enum for dropdown menu\r\nenum TurnDirection {\r\n    Left,\r\n    Right\r\n}"}]},{"timestamp":1764808159413,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":2059,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"69\" y=\"49\"><statement name=\"HANDLER\"><block type=\"smartCar_setupAndCalibrate\"><next><block type=\"controls_repeat_ext\"><value name=\"TIMES\"><shadow type=\"math_whole_number\"><field name=\"NUM\">3</field></shadow></value><statement name=\"DO\"><block type=\"setAllMotor\"><value name=\"m1speed\"><shadow type=\"math_number_minmax\"><mutation min=\"-100\" max=\"100\" label=\"M1speed\" precision=\"0\"></mutation><field name=\"SLIDER\">100</field></shadow></value><value name=\"m2speed\"><shadow type=\"math_number_minmax\"><mutation min=\"-100\" max=\"100\" label=\"M2speed\" precision=\"0\"></mutation><field name=\"SLIDER\">100</field></shadow></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">3000</field></shadow></value><next><block type=\"smartCar_turn\"><field name=\"direction\">TurnDirection.Right</field><value name=\"target_angle\"><shadow type=\"math_number\"><field name=\"NUM\">90</field></shadow></value><value name=\"speed\"><shadow type=\"math_number_minmax\"><mutation min=\"20\" max=\"100\" label=\"Speed\" precision=\"0\"></mutation><field name=\"SLIDER\">50</field></shadow></value></block></next></block></next></block></statement><next><block type=\"smartCar_turn\"><field name=\"direction\">TurnDirection.Right</field><value name=\"target_angle\"><shadow type=\"math_number\"><field name=\"NUM\">90</field></shadow></value><value name=\"speed\"><shadow type=\"math_number_minmax\"><mutation min=\"20\" max=\"100\" label=\"Speed\" precision=\"0\"></mutation><field name=\"SLIDER\">50</field></shadow></value></block></next></block></next></block></statement></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":316,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1764807032238,"editorVersion":"8.0.18","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"SmartCarLibrary\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1764808397497}